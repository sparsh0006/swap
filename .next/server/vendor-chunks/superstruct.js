"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct";
exports.ids = ["vendor-chunks/superstruct"];
exports.modules = {

/***/ "(ssr)/./node_modules/superstruct/dist/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/superstruct/dist/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null) this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            return cached ?? (cached = [\n                failure,\n                ...failures()\n            ]);\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */ function isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    if (typeof value === \"symbol\") {\n        return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch,\n        mask\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = \"valid\";\n    for (const failure of struct.validator(value, ctx)){\n        failure.explanation = options.message;\n        status = \"not_valid\";\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask,\n            message: options.message\n        });\n        for (const t of ts){\n            if (t[0]) {\n                status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    if (v !== undefined || k in value) value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== \"not_valid\") {\n        for (const failure of struct.refiner(value, ctx)){\n            failure.explanation = options.message;\n            status = \"not_refined\";\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (status === \"valid\") {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */ assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */ create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */ is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */ mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct, message) {\n    const result = validate(value, struct, {\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === \"type\") {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || `Expected a function, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = {\n                ...value\n            };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for(const key in coerced){\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isNonArrayObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isNonArrayObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            for (const S of Structs){\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDRDs7Ozs7OztDQU9DLEdBQ0QsTUFBTUEsb0JBQW9CQztJQUN0QkMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDM0IsSUFBSUM7UUFDSixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxFQUFFLEdBQUdDLE1BQU0sR0FBR0w7UUFDMUMsTUFBTSxFQUFFTSxJQUFJLEVBQUUsR0FBR047UUFDakIsTUFBTU8sTUFBTUQsS0FBS0UsTUFBTSxLQUFLLElBQUlMLFVBQVUsQ0FBQyxTQUFTLEVBQUVHLEtBQUtHLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRU4sUUFBUSxDQUFDO1FBQ3BGLEtBQUssQ0FBQ0MsZUFBZUc7UUFDckIsSUFBSUgsZUFBZSxNQUNmLElBQUksQ0FBQ00sS0FBSyxHQUFHSDtRQUNqQkksT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVA7UUFDcEIsSUFBSSxDQUFDUSxJQUFJLEdBQUcsSUFBSSxDQUFDZCxXQUFXLENBQUNjLElBQUk7UUFDakMsSUFBSSxDQUFDWixRQUFRLEdBQUc7WUFDWixPQUFRQyxVQUFXQSxDQUFBQSxTQUFTO2dCQUFDRjttQkFBWUM7YUFBVztRQUN4RDtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELFNBQVNhLFdBQVdDLENBQUM7SUFDakIsT0FBT0MsU0FBU0QsTUFBTSxPQUFPQSxDQUFDLENBQUNFLE9BQU9DLFFBQVEsQ0FBQyxLQUFLO0FBQ3hEO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRixTQUFTRCxDQUFDO0lBQ2YsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLEtBQUs7QUFDekM7QUFDQTs7Q0FFQyxHQUNELFNBQVNJLGlCQUFpQkosQ0FBQztJQUN2QixPQUFPQyxTQUFTRCxNQUFNLENBQUNLLE1B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LEdBQ0QsU0FBUzhJLE9BQU8vRyxNQUFNLEVBQUUxQixJQUFJLEVBQUVtRCxPQUFPO0lBQ2pDLE9BQU8sSUFBSUMsT0FBTztRQUNkLEdBQUcxQixNQUFNO1FBQ1QsQ0FBQ3lCLFNBQVFwQyxLQUFLLEVBQUVzQixHQUFHO1lBQ2YsT0FBT1gsT0FBT3lCLE9BQU8sQ0FBQ3BDLE9BQU9zQjtZQUM3QixNQUFNYixTQUFTMkIsUUFBUXBDLE9BQU9zQjtZQUM5QixNQUFNakQsV0FBVzJDLFdBQVdQLFFBQVFhLEtBQUtYLFFBQVFYO1lBQ2pELEtBQUssTUFBTTVCLFdBQVdDLFNBQVU7Z0JBQzVCLE1BQU07b0JBQUUsR0FBR0QsT0FBTztvQkFBRTBDLFlBQVk3QjtnQkFBSztZQUN6QztRQUNKO0lBQ0o7QUFDSjtBQUU2WixDQUM3WixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb25pYy1zd2FwLy4vbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXgubWpzPzQ0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgICAgIGxldCBjYWNoZWQ7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gZmFpbHVyZTtcbiAgICAgICAgY29uc3QgbXNnID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICBpZiAoZXhwbGFuYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBtc2c7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpdGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIG5vbi1hcnJheSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uQXJyYXlPYmplY3QoeCkge1xuICAgIHJldHVybiBpc09iamVjdCh4KSAmJiAhQXJyYXkuaXNBcnJheSh4KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xufVxuLyoqXG4gKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAqL1xuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKTtcbiAgICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGgsIGJyYW5jaCB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLCB9ID0gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZWZpbmVtZW50LFxuICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYnJhbmNoLFxuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYXRoID0gW10sIGJyYW5jaCA9IFt2YWx1ZV0sIGNvZXJjZSA9IGZhbHNlLCBtYXNrID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2gsIG1hc2sgfTtcbiAgICBpZiAoY29lcmNlKSB7XG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGxldCBzdGF0dXMgPSAndmFsaWQnO1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgIGNvbnN0IHRzID0gcnVuKHYsIHMsIHtcbiAgICAgICAgICAgIHBhdGg6IGsgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwga10sXG4gICAgICAgICAgICBicmFuY2g6IGsgPT09IHVuZGVmaW5lZCA/IGJyYW5jaCA6IFsuLi5icmFuY2gsIHZdLFxuICAgICAgICAgICAgY29lcmNlLFxuICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0WzBdLnJlZmluZW1lbnQgIT0gbnVsbCA/ICdub3RfcmVmaW5lZCcgOiAnbm90X3ZhbGlkJztcbiAgICAgICAgICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgICAgIHYgPSB0WzFdO1xuICAgICAgICAgICAgICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zZXQoaywgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmFkZCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgfHwgayBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXR1cyAhPT0gJ25vdF92YWxpZCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICAgICAgc3RhdHVzID0gJ25vdF9yZWZpbmVkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5jbGFzcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgc2NoZW1hLCB2YWxpZGF0b3IsIHJlZmluZXIsIGNvZXJjZXIgPSAodmFsdWUpID0+IHZhbHVlLCBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHsgfSwgfSA9IHByb3BzO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcbiAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmaW5lciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAqL1xuICAgIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAgICovXG4gICAgY3JlYXRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLiBNYXNraW5nIGFwcGxpZXMgcmVjdXJzaXZlbHkgdG9cbiAgICAgKiBwcm9wcyBvZiBgb2JqZWN0YCBzdHJ1Y3RzIG9ubHkuXG4gICAgICovXG4gICAgbWFzayh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWFzayh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiBsb2dpYywgcmV0dXJuaW5nIGEgdHVwbGVcbiAgICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIFlvdSBtYXkgb3B0aW9uYWxseSBwYXNzIGB0cnVlYCBmb3IgdGhlIGBjb2VyY2VgIGFyZ3VtZW50IHRvIGNvZXJjZVxuICAgICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICAgKiBjb250YWluIHRoZSBjb2VyY2VkIHJlc3VsdCB3aGVuIHN1Y2Nlc3NmdWwuIEFsc28sIGBtYXNrYCB3aWxsIHR1cm4gb25cbiAgICAgKiBtYXNraW5nIG9mIHRoZSB1bmtub3duIGBvYmplY3RgIHByb3BzIHJlY3Vyc2l2ZWx5IGlmIHBhc3NlZC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5mdW5jdGlvbiBjcmVhdGUodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgIGlmICh0dXBsZVswXSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gICAgY29uc3QgaXNUeXBlID0gU3RydWN0c1swXS50eXBlID09PSAndHlwZSc7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gICAgcmV0dXJuIGlzVHlwZSA/IHR5cGUoc2NoZW1hKSA6IG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyB0eXBlOiBuYW1lLCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvciB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICBjb25zdCBpc1N0cnVjdCA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdDtcbiAgICBjb25zdCBzY2hlbWEgPSBpc1N0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYSB9IDogeyAuLi5zdHJ1Y3QgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdCAmJiBzdHJ1Y3QudHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHJldHVybiB0eXBlKHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gICAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYW55KCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdiaWdpbnQnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5mdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2RhdGUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgdmFsaWQgXFxgRGF0ZVxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdlbnVtcycsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnZnVuYycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYCR7Q2xhc3MubmFtZX1cXGAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNOb25BcnJheU9iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICghaXNOb25BcnJheU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2VyY2VkID0geyAuLi52YWx1ZSB9O1xuICAgICAgICAgICAgLy8gVGhlIGBvYmplY3RgIHN0cnVjdCBoYXMgc3BlY2lhbCBiZWhhdmlvdXIgZW5hYmxlZCBieSB0aGUgbWFzayBmbGFnLlxuICAgICAgICAgICAgLy8gV2hlbiBtYXNraW5nLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgc2NoZW1hIGFyZSBkZWxldGVkIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSBjb2VyY2VkIG9iamVjdCBpbnN0ZWFkIG9mIGV2ZW50dWFsbHkgZmFpbGluZyB2YWxpZGFpdG9uLlxuICAgICAgICAgICAgaWYgKGN0eC5tYXNrICYmIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvZXJjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb2VyY2VkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAncmVjb3JkJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzTm9uQXJyYXlPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm9uQXJyYXlPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAqIHlvdSBuZWVkIHRvIHVzZSB0aGUgYHBhdHRlcm4oKWAgcmVmaW5lbWVudC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ3JlZ2V4cCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXQoRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3NldCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChFbGVtZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFt2LCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCA/IG5ldyBTZXQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYFNldFxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdzdHJpbmcnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB0dXBsZSBvZiBhIHNwZWNpZmljIGxlbmd0aCwgYW5kIHRoYXQgZWFjaCBvZiBpdHNcbiAqIGVsZW1lbnRzIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdHVwbGUoU3RydWN0cykge1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFN0cnVjdHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBTdHJ1Y3RzW2ldIHx8IE5ldmVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqL1xuZnVuY3Rpb24gdHlwZShzY2hlbWEpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd0eXBlJyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc05vbkFycmF5T2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vbkFycmF5T2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5mdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcCgocykgPT4gcy50eXBlKS5qb2luKCcgfCAnKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlcnJvciwgY29lcmNlZF0gPSBTLnZhbGlkYXRlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWFzazogY3R4Lm1hc2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9IHJ1bih2YWx1ZSwgUywgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCB0aGUgdmFsdWUgdG8gc2F0aXNmeSBhIHVuaW9uIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWAsXG4gICAgICAgICAgICAgICAgLi4uZmFpbHVyZXMsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24sIHdpdGhvdXQgd2lkZW5pbmcgaXRzIHR5cGUgdG8gYGFueWAuXG4gKi9cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gICAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCBjb2VyY2lvbiBzdGVwIHRvIGl0cyBpbnB1dC5cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIGlucHV0IGRhdGEgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHRvIGluY3JlYXNlIHRoZVxuICogbGlrZWxpaG9vZCB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9u4oCUZm9yIGV4YW1wbGUgZm9yIGRlZmF1bHQgdmFsdWVzLCBwYXJzaW5nXG4gKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5mdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KVxuICAgICAgICAgICAgICAgIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gcmVwbGFjZSBgdW5kZWZpbmVkYCB2YWx1ZXMgd2l0aCBhIGRlZmF1bHQuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCAoeCkgPT4ge1xuICAgICAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0geyAuLi54IH07XG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZltrZXldO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gdHJpbSBzdHJpbmcgaW5wdXRzLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5mdW5jdGlvbiB0cmltbWVkKHN0cnVjdCkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCBzdHJpbmcoKSwgKHgpID0+IHgudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5mdW5jdGlvbiBlbXB0eShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChzaXplID09PSAwIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBsZXNzIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICovXG5mdW5jdGlvbiBtaW4oc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZXhjbHVzaXZlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgID8gdmFsdWUgPiB0aHJlc2hvbGRcbiAgICAgICAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gZ3JlYXRlciB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAgb3Igc2V0IGlzIG5vdCBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gbm9uZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdub25lbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA+IDAgfHwgYEV4cGVjdGVkIGEgbm9uZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIGFuIGVtcHR5IG9uZWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCwgcmVnZXhwKSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBtYXRjaGluZyBcXGAvJHtyZWdleHAuc291cmNlfS9cXGAgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cImApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG51bWJlciwgZGF0ZSwgbWFwLCBvciBzZXQgaGFzIGEgc2l6ZSAob3IgbGVuZ3RoLCBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqL1xuZnVuY3Rpb24gc2l6ZShzdHJ1Y3QsIG1pbiwgbWF4ID0gbWluKSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfWA7XG4gICAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IGBvZiBcXGAke21pbn1cXGBgIDogYGJldHdlZW4gXFxgJHttaW59XFxgIGFuZCBcXGAke21heH1cXGBgO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnc2l6ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9ICR7b2Z9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IHNpemUgJiYgc2l6ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgbGVuZ3RoICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIGxlbmd0aCBvZiBcXGAke2xlbmd0aH1cXGBgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBTdHJ1Y3QsIFN0cnVjdEVycm9yLCBhbnksIGFycmF5LCBhc3NlcnQsIGFzc2lnbiwgYmlnaW50LCBib29sZWFuLCBjb2VyY2UsIGNyZWF0ZSwgZGF0ZSwgZGVmYXVsdGVkLCBkZWZpbmUsIGRlcHJlY2F0ZWQsIGR5bmFtaWMsIGVtcHR5LCBlbnVtcywgZnVuYywgaW5zdGFuY2UsIGludGVnZXIsIGludGVyc2VjdGlvbiwgaXMsIGxhenksIGxpdGVyYWwsIG1hcCwgbWFzaywgbWF4LCBtaW4sIG5ldmVyLCBub25lbXB0eSwgbnVsbGFibGUsIG51bWJlciwgb2JqZWN0LCBvbWl0LCBvcHRpb25hbCwgcGFydGlhbCwgcGF0dGVybiwgcGljaywgcmVjb3JkLCByZWZpbmUsIHJlZ2V4cCwgc2V0LCBzaXplLCBzdHJpbmcsIHN0cnVjdCwgdHJpbW1lZCwgdHVwbGUsIHR5cGUsIHVuaW9uLCB1bmtub3duLCB2YWxpZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlN0cnVjdEVycm9yIiwiVHlwZUVycm9yIiwiY29uc3RydWN0b3IiLCJmYWlsdXJlIiwiZmFpbHVyZXMiLCJjYWNoZWQiLCJtZXNzYWdlIiwiZXhwbGFuYXRpb24iLCJyZXN0IiwicGF0aCIsIm1zZyIsImxlbmd0aCIsImpvaW4iLCJjYXVzZSIsIk9iamVjdCIsImFzc2lnbiIsIm5hbWUiLCJpc0l0ZXJhYmxlIiwieCIsImlzT2JqZWN0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc05vbkFycmF5T2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiaXNQbGFpbk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImdldFByb3RvdHlwZU9mIiwicHJpbnQiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaGlmdEl0ZXJhdG9yIiwiaW5wdXQiLCJkb25lIiwibmV4dCIsInVuZGVmaW5lZCIsInRvRmFpbHVyZSIsInJlc3VsdCIsImNvbnRleHQiLCJzdHJ1Y3QiLCJicmFuY2giLCJ0eXBlIiwicmVmaW5lbWVudCIsImtleSIsInRvRmFpbHVyZXMiLCJyIiwicnVuIiwib3B0aW9ucyIsImNvZXJjZSIsIm1hc2siLCJjdHgiLCJjb2VyY2VyIiwic3RhdHVzIiwidmFsaWRhdG9yIiwiayIsInYiLCJzIiwiZW50cmllcyIsInRzIiwidCIsIk1hcCIsInNldCIsIlNldCIsImFkZCIsInJlZmluZXIiLCJTdHJ1Y3QiLCJwcm9wcyIsInNjaGVtYSIsImFzc2VydCIsImNyZWF0ZSIsImlzIiwidmFsaWRhdGUiLCJ0dXBsZXMiLCJ0dXBsZSIsImVycm9yIiwiU3RydWN0cyIsImlzVHlwZSIsInNjaGVtYXMiLCJtYXAiLCJvYmplY3QiLCJkZWZpbmUiLCJkZXByZWNhdGVkIiwibG9nIiwiZHluYW1pYyIsImZuIiwibGF6eSIsIm9taXQiLCJrZXlzIiwic3Vic2NoZW1hIiwicGFydGlhbCIsImlzU3RydWN0Iiwib3B0aW9uYWwiLCJwaWNrIiwiY29uc29sZSIsIndhcm4iLCJhbnkiLCJhcnJheSIsIkVsZW1lbnQiLCJpIiwic2xpY2UiLCJiaWdpbnQiLCJib29sZWFuIiwiZGF0ZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJlbnVtcyIsInZhbHVlcyIsImRlc2NyaXB0aW9uIiwiaW5jbHVkZXMiLCJmdW5jIiwiaW5zdGFuY2UiLCJDbGFzcyIsImludGVnZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpbnRlcnNlY3Rpb24iLCJTIiwibGl0ZXJhbCIsImNvbnN0YW50IiwiS2V5IiwiVmFsdWUiLCJuZXZlciIsIm51bGxhYmxlIiwibnVtYmVyIiwia25vd25zIiwiTmV2ZXIiLCJ1bmtub3ducyIsImRlbGV0ZSIsImNvZXJjZWQiLCJyZWNvcmQiLCJyZWdleHAiLCJSZWdFeHAiLCJzdHJpbmciLCJNYXRoIiwibWF4IiwidW5pb24iLCJmaXJzdCIsInB1c2giLCJ1bmtub3duIiwiY29uZGl0aW9uIiwiZGVmYXVsdGVkIiwiZmFsbGJhY2siLCJmIiwic3RyaWN0IiwicmV0IiwiY2hhbmdlZCIsInRyaW1tZWQiLCJ0cmltIiwiZW1wdHkiLCJyZWZpbmUiLCJzaXplIiwiZ2V0U2l6ZSIsInRocmVzaG9sZCIsImV4Y2x1c2l2ZSIsIm1pbiIsIm5vbmVtcHR5IiwicGF0dGVybiIsInRlc3QiLCJzb3VyY2UiLCJleHBlY3RlZCIsIm9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/superstruct/dist/index.mjs\n");

/***/ })

};
;